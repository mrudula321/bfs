#include <iostream>
#include <vector>
#include <queue>
#include <omp.h>

using namespace std;

// Function to perform parallel BFS
void parallelBFS(vector<vector<int>>& graph, int startNode) {
int numNodes = graph.size();
vector<bool> visited(numNodes, false);
queue<int> bfsQueue;

// Initialize the BFS queue with the starting node
bfsQueue.push(startNode);
visited[startNode] = true;

while (!bfsQueue.empty()) {
int currentNode = bfsQueue.front();
bfsQueue.pop();
cout << "Visited Node: " << currentNode << endl;

// Parallelize the loop for exploring the neighbors of the current node
#pragma omp parallel for
for (int i = 0; i < numNodes; ++i) {
if (graph[currentNode][i] && !visited[i]) {
visited[i] = true;
bfsQueue.push(i);

}
}
}
}
#include <iostream>
#include <vector>
#include <stack>
#include <omp.h>

using namespace std;

// Function to perform parallel DFS
void parallelDFS(vector<vector<int>>& graph, int startNode) {
int numNodes = graph.size();
vector<bool> visited(numNodes, false);
stack<int> dfsStack;

// Initialize the DFS stack with the starting node
dfsStack.push(startNode);

while (!dfsStack.empty()) {
int currentNode = dfsStack.top();
dfsStack.pop();

if (!visited[currentNode]) {
cout << "Visited Node: " << currentNode << endl;
visited[currentNode] = true;
}

// Parallelize the loop for exploring the neighbors of the current node
#pragma omp parallel for

for (int i = 0; i < numNodes; ++i) {
if (graph[currentNode][i] && !visited[i]) {
dfsStack.push(i);
}
}
}
}

int main() {
// Construct an undirected graph
vector<vector<int>> graph = {
{0, 1, 1, 0, 0},
{1, 0, 1, 1, 0},
{1, 1, 0, 0, 1},
{0, 1, 0, 0, 1},
{0, 0, 1, 1, 0}
};

// Perform parallel BFS starting from node 0
cout << "Parallel Breadth First Search:" << endl;
parallelBFS(graph, 0);

// Perform parallel DFS starting from node 0
cout << "Parallel Depth First Search:" << endl;
parallelDFS(graph, 0);

return 0;
}